åŸºäºæ‚¨çš„éœ€æ±‚å’Œæä¾›çš„å®æ–½æ–¹æ¡ˆï¼Œæˆ‘æ¥åˆ¶å®šä¸€ä¸ªå®Œæ•´çš„æ™ºèƒ½è®°å¿†å¢å¼ºç³»ç»Ÿå®æ–½è®¡åˆ’ã€‚è¿™ä¸ªç³»ç»Ÿå°†å……åˆ†åˆ©ç”¨ Zen MCP Server çš„ç°æœ‰æ¶æ„ï¼Œå®ç°æ‚¨æœŸæœ›çš„æ‰€æœ‰åŠŸèƒ½ã€‚

## ğŸ“‹ å®æ–½è®¡åˆ’æ¦‚è§ˆ

### ç¬¬ä¸€é˜¶æ®µï¼šæ ¸å¿ƒè®°å¿†ç³»ç»Ÿå®ç°ï¼ˆDay 1-2ï¼‰

#### 1. æ‰©å±•ç°æœ‰è®°å¿†ç³»ç»Ÿ

é¦–å…ˆï¼ŒåŸºäºç°æœ‰çš„ `conversation_memory.py`ï¼Œåˆ›å»ºå¢å¼ºç‰ˆè®°å¿†ç³»ç»Ÿï¼š

```python
# utils/enhanced_memory.py
"""æ‰©å±•çš„è®°å¿†ç³»ç»Ÿï¼Œæ”¯æŒä¸‰å±‚è®°å¿†å’Œæ™ºèƒ½è·¯å¾„ç®¡ç†"""

import json
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
from utils.conversation_memory import ConversationMemory

class EnhancedMemory(ConversationMemory):
    """å¢å¼ºç‰ˆè®°å¿†ç³»ç»Ÿ - æ”¯æŒå…¨å±€ã€é¡¹ç›®å’Œä¼šè¯ä¸‰å±‚è®°å¿†"""
    
    def __init__(self):
        super().__init__()
        
        # è®°å¿†å­˜å‚¨è·¯å¾„
        self.memory_base = Path(os.getenv("WORKSPACE_ROOT", ".")) / ".zen_memory"
        self.memory_base.mkdir(exist_ok=True)
        
        # åˆå§‹åŒ–ä¸‰å±‚è®°å¿†å­˜å‚¨
        self.global_memory_file = self.memory_base / "global_memory.json"
        self.project_memory_file = self.memory_base / "project_memory.json"
        
        # åŠ è½½æŒä¹…åŒ–è®°å¿†
        self.global_memory = self._load_memory_file(self.global_memory_file)
        self.project_memory = self._load_memory_file(self.project_memory_file)
        
        # åˆå§‹åŒ–è·¯å¾„è®°å¿†
        self._init_path_memory()
        
        # åˆå§‹åŒ–TODOç®¡ç†å™¨
        self._init_todo_manager()
    
    def _init_path_memory(self):
        """åˆå§‹åŒ–è·¯å¾„è®°å¿†åŠŸèƒ½"""
        self.path_memory = {
            "virtual_envs": {},  # è™šæ‹Ÿç¯å¢ƒè·¯å¾„
            "project_structure": {},  # é¡¹ç›®ç»“æ„
            "file_patterns": {},  # æ–‡ä»¶åˆ›å»ºæ¨¡å¼
            "command_contexts": {}  # å‘½ä»¤æ‰§è¡Œä¸Šä¸‹æ–‡
        }
        
        # ä»è®°å¿†ä¸­æ¢å¤è·¯å¾„ä¿¡æ¯
        if "paths" in self.project_memory:
            self.path_memory.update(self.project_memory["paths"])
    
    def detect_and_remember_venv(self, project_path: str) -> Optional[str]:
        """è‡ªåŠ¨æ£€æµ‹å¹¶è®°ä½è™šæ‹Ÿç¯å¢ƒè·¯å¾„"""
        project_path = Path(project_path)
        
        # å¸¸è§çš„è™šæ‹Ÿç¯å¢ƒåç§°
        venv_names = ['.venv', 'venv', '.env', 'env', '.zen_venv']
        
        for venv_name in venv_names:
            venv_path = project_path / venv_name
            if venv_path.exists() and (venv_path / 'bin' / 'python').exists():
                # è®°ä½è¿™ä¸ªé¡¹ç›®çš„è™šæ‹Ÿç¯å¢ƒ
                self.path_memory["virtual_envs"][str(project_path)] = str(venv_path)
                self._save_path_memory()
                return str(venv_path)
        
        return None
    
    def get_smart_file_location(self, filename: str, context: Dict) -> str:
        """æ™ºèƒ½å†³å®šæ–‡ä»¶åˆ›å»ºä½ç½®"""
        project_root = context.get("project_root", ".")
        file_type = Path(filename).suffix
        
        # åŸºäºæ–‡ä»¶ç±»å‹çš„æ™ºèƒ½è·¯å¾„é€‰æ‹©
        type_patterns = {
            ".py": ["src", "lib", "utils", "."],
            ".md": ["docs", "documentation", "."],
            ".json": ["config", "conf", "."],
            ".yaml": ["config", "conf", "."],
            ".yml": ["config", "conf", "."],
        }
        
        # æŸ¥æ‰¾åˆé€‚çš„ç›®å½•
        patterns = type_patterns.get(file_type, ["."])
        for pattern in patterns:
            target_dir = Path(project_root) / pattern
            if target_dir.exists() and target_dir.is_dir():
                return str(target_dir / filename)
        
        # é»˜è®¤åœ¨é¡¹ç›®æ ¹ç›®å½•
        return str(Path(project_root) / filename)
    
    def _init_todo_manager(self):
        """åˆå§‹åŒ–TODOç®¡ç†åŠŸèƒ½"""
        self.todo_manager = {
            "main_thread": [],  # ä¸»çº¿ä»»åŠ¡
            "branches": {},  # åˆ†æ”¯ä»»åŠ¡
            "current_context": "main",  # å½“å‰ä¸Šä¸‹æ–‡
            "task_history": []  # ä»»åŠ¡å†å²
        }
        
        # ä»è®°å¿†ä¸­æ¢å¤TODOçŠ¶æ€
        if "todo_state" in self.project_memory:
            self.todo_manager.update(self.project_memory["todo_state"])
    
    def parse_todo_file(self, todo_path: str) -> Dict:
        """è§£æTODOæ–‡ä»¶å¹¶æ›´æ–°ä¸»çº¿ä»»åŠ¡"""
        # å®ç°TODOæ–‡ä»¶è§£æé€»è¾‘
        todos = []
        with open(todo_path, 'r', encoding='utf-8') as f:
            for line in f:
                if line.strip().startswith('- [ ]'):
                    todos.append({
                        "task": line.strip()[6:],
                        "status": "pending",
                        "created": datetime.now().isoformat()
                    })
        
        self.todo_manager["main_thread"] = todos
        self._save_todo_state()
        return {"parsed": len(todos), "tasks": todos}
    
    def create_task_branch(self, branch_name: str, context: str) -> str:
        """åˆ›å»ºä¸´æ—¶ä»»åŠ¡åˆ†æ”¯"""
        branch_id = f"branch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.todo_manager["branches"][branch_id] = {
            "name": branch_name,
            "context": context,
            "tasks": [],
            "created": datetime.now().isoformat(),
            "parent": self.todo_manager["current_context"]
        }
        
        # åˆ‡æ¢åˆ°åˆ†æ”¯ä¸Šä¸‹æ–‡
        self.todo_manager["current_context"] = branch_id
        self._save_todo_state()
        
        return branch_id
    
    def return_to_main_thread(self) -> Dict:
        """ä»åˆ†æ”¯è¿”å›ä¸»çº¿"""
        current = self.todo_manager["current_context"]
        if current != "main" and current in self.todo_manager["branches"]:
            # è®°å½•åˆ†æ”¯å®Œæˆ
            branch = self.todo_manager["branches"][current]
            branch["completed"] = datetime.now().isoformat()
            
            # è¿”å›ä¸»çº¿
            self.todo_manager["current_context"] = "main"
            self._save_todo_state()
            
            return {
                "status": "returned_to_main",
                "branch_summary": branch
            }
        
        return {"status": "already_on_main"}
```

#### 2. å®ç°è®°å¿†å·¥å…·

```python
# tools/simple/memory.py
"""è®°å¿†ç®¡ç†å·¥å…· - æ”¯æŒæ™ºèƒ½è·¯å¾„è¯†åˆ«å’ŒTODOç®¡ç†"""

from typing import Dict, List, Optional
from tools.base_tool import BaseTool, ToolRequest, ToolOutput
from utils.enhanced_memory import EnhancedMemory
import json

class MemoryTool(BaseTool):
    """è®°å¿†ç®¡ç†å·¥å…·"""
    
    def __init__(self):
        super().__init__()
        self.memory_system = EnhancedMemory()
        
    def get_name(self) -> str:
        return "memory"
    
    def get_description(self) -> str:
        return "Manage memories, paths, and TODO tasks intelligently"
    
    async def run(self, request: ToolRequest) -> ToolOutput:
        """æ‰§è¡Œè®°å¿†æ“ä½œ"""
        try:
            action = request.params.get("action", "recall")
            
            if action == "save":
                result = await self._save_memory(request)
            elif action == "recall":
                result = await self._recall_memory(request)
            elif action == "detect_venv":
                result = await self._detect_virtual_env(request)
            elif action == "smart_path":
                result = await self._get_smart_path(request)
            elif action == "parse_todo":
                result = await self._parse_todo(request)
            elif action == "create_branch":
                result = await self._create_task_branch(request)
            elif action == "return_main":
                result = await self._return_to_main(request)
            elif action == "analyze":
                result = await self._analyze_patterns(request)
            else:
                raise ValueError(f"Unknown action: {action}")
            
            return ToolOutput(
                status="success",
                content=json.dumps(result, indent=2),
                metadata={
                    "tool_name": self.get_name(),
                    "action": action
                }
            )
            
        except Exception as e:
            return ToolOutput(
                status="error",
                error=str(e)
            )
    
    async def _detect_virtual_env(self, request: ToolRequest) -> Dict:
        """æ£€æµ‹å¹¶è®°ä½è™šæ‹Ÿç¯å¢ƒ"""
        project_path = request.params.get("project_path", ".")
        venv_path = self.memory_system.detect_and_remember_venv(project_path)
        
        if venv_path:
            # ä¿å­˜åˆ°é¡¹ç›®è®°å¿†
            self.memory_system.save_memory(
                content={
                    "type": "virtual_env",
                    "project": project_path,
                    "venv_path": venv_path,
                    "python": f"{venv_path}/bin/python",
                    "pip": f"{venv_path}/bin/pip"
                },
                memory_type="project",
                tags=["environment", "python", "venv"]
            )
            
            return {
                "found": True,
                "venv_path": venv_path,
                "commands": {
                    "python": f"{venv_path}/bin/python",
                    "pip": f"{venv_path}/bin/pip"
                }
            }
        
        return {"found": False, "message": "No virtual environment detected"}
    
    async def _get_smart_path(self, request: ToolRequest) -> Dict:
        """è·å–æ™ºèƒ½æ–‡ä»¶åˆ›å»ºè·¯å¾„"""
        filename = request.params.get("filename")
        context = request.params.get("context", {})
        
        smart_path = self.memory_system.get_smart_file_location(filename, context)
        
        return {
            "filename": filename,
            "suggested_path": smart_path,
            "reason": "Based on project structure and file type patterns"
        }
```

#### 3. å®ç°æ€ç»´å·¥å…·ç®±

```python
# tools/workflow/thinking.py
"""æ€ç»´å·¥å…·ç®± - å¤šæ¨¡å¼æ€ç»´å’Œä»»åŠ¡ç®¡ç†"""

from typing import Dict, List, Optional
from tools.workflow.base_workflow import BaseWorkflowTool
from utils.enhanced_memory import EnhancedMemory
import json

class ThinkingTool(BaseWorkflowTool):
    """å¤šæ¨¡å¼æ€ç»´å·¥å…·ï¼Œé›†æˆä»»åŠ¡ç®¡ç†"""
    
    def __init__(self):
        super().__init__()
        self.memory_system = EnhancedMemory()
        
        # æ€ç»´æ¨¡å¼å®šä¹‰
        self.thinking_modes = {
            "analyze_intent": "åˆ†æç”¨æˆ·æ„å›¾å’Œéœ€æ±‚",
            "decompose": "åˆ†è§£å¤æ‚é—®é¢˜ä¸ºå­ä»»åŠ¡",
            "path_context": "åˆ†æè·¯å¾„å’Œç¯å¢ƒä¸Šä¸‹æ–‡",
            "task_planning": "è§„åˆ’ä»»åŠ¡æ‰§è¡Œé¡ºåº",
            "branch_decision": "å†³å®šæ˜¯å¦éœ€è¦åˆ›å»ºä»»åŠ¡åˆ†æ”¯",
            "solution_synthesis": "ç»¼åˆè§£å†³æ–¹æ¡ˆ"
        }
        
    def get_name(self) -> str:
        return "think"
        
    def get_description(self) -> str:
        return "Structured thinking with task management awareness"
    
    async def run_workflow(self, request: ToolRequest) -> ToolOutput:
        """æ‰§è¡Œæ€ç»´å·¥ä½œæµ"""
        mode = request.params.get("mode", "auto")
        problem = request.params.get("problem")
        
        # è‡ªåŠ¨æ¨¡å¼ï¼šåˆ†æé—®é¢˜ç±»å‹å¹¶é€‰æ‹©æ€ç»´æ¨¡å¼
        if mode == "auto":
            mode = await self._analyze_and_select_mode(problem)
        
        # ä»è®°å¿†ä¸­è·å–ç›¸å…³ä¸Šä¸‹æ–‡
        context = self._gather_context(problem)
        
        # æ‰§è¡Œæ€ç»´æµç¨‹
        workflow_steps = self._get_workflow_steps(mode)
        results = []
        
        for step in workflow_steps:
            step_result = await self._execute_thinking_step(
                step=step,
                problem=problem,
                context=context,
                previous_results=results
            )
            results.append(step_result)
        
        # ç»¼åˆç»“æœå¹¶æ›´æ–°è®°å¿†
        final_analysis = self._synthesize_results(mode, results)
        
        # å¦‚æœæ¶‰åŠä»»åŠ¡ç®¡ç†ï¼Œæ›´æ–°TODOçŠ¶æ€
        if "task_management" in final_analysis:
            self._update_task_state(final_analysis["task_management"])
        
        return ToolOutput(
            status="success",
            content=json.dumps(final_analysis, indent=2),
            metadata={
                "mode": mode,
                "steps_executed": len(results)
            }
        )
    
    def _gather_context(self, problem: str) -> Dict:
        """ä»è®°å¿†ä¸­æ”¶é›†ç›¸å…³ä¸Šä¸‹æ–‡"""
        context = {
            "current_task": self.memory_system.todo_manager["current_context"],
            "recent_operations": [],
            "environment": {},
            "patterns": []
        }
        
        # è·å–ç¯å¢ƒä¿¡æ¯
        env_memories = self.memory_system.recall_memories(
            query="virtual_env python pip",
            scopes=["project"],
            limit=5
        )
        for memory in env_memories:
            if memory.get("content", {}).get("type") == "virtual_env":
                context["environment"]["venv"] = memory["content"]
        
        # è·å–æœ€è¿‘çš„æ“ä½œè®°å½•
        recent_ops = self.memory_system.recall_memories(
            query=problem,
            scopes=["session", "project"],
            limit=10
        )
        context["recent_operations"] = recent_ops
        
        return context
    
    async def _analyze_and_select_mode(self, problem: str) -> str:
        """æ™ºèƒ½åˆ†æé—®é¢˜å¹¶é€‰æ‹©æ€ç»´æ¨¡å¼"""
        problem_lower = problem.lower()
        
        # åŸºäºå…³é”®è¯çš„æ¨¡å¼é€‰æ‹©
        if any(word in problem_lower for word in ["è·¯å¾„", "ä½ç½®", "æ‰¾ä¸åˆ°", "ç¯å¢ƒ"]):
            return "path_context"
        elif any(word in problem_lower for word in ["ä»»åŠ¡", "todo", "è®¡åˆ’", "æ­¥éª¤"]):
            return "task_planning"
        elif any(word in problem_lower for word in ["ä¸´æ—¶", "å…ˆ", "ç¨å", "å›æ¥"]):
            return "branch_decision"
        elif any(word in problem_lower for word in ["åˆ†è§£", "æ‹†åˆ†", "å¤æ‚"]):
            return "decompose"
        else:
            return "analyze_intent"
```

### ç¬¬äºŒé˜¶æ®µï¼šè‡ªåŠ¨è§¦å‘æœºåˆ¶ï¼ˆDay 3ï¼‰

#### 1. ä¿®æ”¹ server.py é›†æˆè‡ªåŠ¨è§¦å‘

```python
# åœ¨ server.py ä¸­æ·»åŠ ä¼šè¯åˆå§‹åŒ–é’©å­

async def handle_initialize(request):
    """å¤„ç†åˆå§‹åŒ–è¯·æ±‚ï¼Œè‡ªåŠ¨è§¦å‘è®°å¿†ç³»ç»Ÿ"""
    # åŸæœ‰çš„åˆå§‹åŒ–é€»è¾‘...
    
    # è‡ªåŠ¨è§¦å‘è®°å¿†ç³»ç»Ÿ
    memory_system = EnhancedMemory()
    thinking_tool = ThinkingTool()
    
    # æ£€æµ‹é¡¹ç›®ç¯å¢ƒ
    project_root = os.getcwd()
    venv_result = memory_system.detect_and_remember_venv(project_root)
    
    # åŠ è½½TODOçŠ¶æ€
    todo_file = Path(project_root) / "TODO.md"
    if todo_file.exists():
        memory_system.parse_todo_file(str(todo_file))
    
    # å‡†å¤‡åˆå§‹ä¸Šä¸‹æ–‡
    initial_context = {
        "project_root": project_root,
        "virtual_env": venv_result,
        "todo_status": memory_system.todo_manager,
        "timestamp": datetime.now().isoformat()
    }
    
    # ä¿å­˜ä¼šè¯å¼€å§‹è®°å¿†
    memory_system.save_memory(
        content={
            "type": "session_start",
            "context": initial_context
        },
        memory_type="session",
        tags=["initialization"]
    )
    
    logger.info(f"Memory system initialized for project: {project_root}")
    
    # è¿”å›å¢å¼ºçš„åˆå§‹åŒ–å“åº”
    return {
        "protocolVersion": "1.0",
        "capabilities": capabilities,
        "serverInfo": server_info,
        "memoryStatus": {
            "initialized": True,
            "virtualEnv": venv_result.get("venv_path") if venv_result else None,
            "todoTasks": len(memory_system.todo_manager["main_thread"])
        }
    }
```

#### 2. å¢å¼ºå·¥å…·è°ƒç”¨å‰çš„è®°å¿†æ³¨å…¥

```python
# åœ¨ handle_tool_call ä¸­æ·»åŠ è®°å¿†ä¸Šä¸‹æ–‡æ³¨å…¥

async def handle_tool_call(request):
    """å¤„ç†å·¥å…·è°ƒç”¨ï¼Œè‡ªåŠ¨æ³¨å…¥è®°å¿†ä¸Šä¸‹æ–‡"""
    tool_name = request.params.get("name")
    tool_params = request.params.get("arguments", {})
    
    # è·å–è®°å¿†ç³»ç»Ÿå®ä¾‹
    memory_system = EnhancedMemory()
    
    # ä¸ºæ¯ä¸ªå·¥å…·è°ƒç”¨æ³¨å…¥ç›¸å…³è®°å¿†
    memory_context = memory_system.get_memory_context(tool_name, tool_params)
    
    # å¦‚æœæ˜¯éœ€è¦è·¯å¾„çš„æ“ä½œï¼Œè‡ªåŠ¨æ³¨å…¥è·¯å¾„ä¿¡æ¯
    if tool_name in ["execute", "create_file", "run_command"]:
        # è·å–è™šæ‹Ÿç¯å¢ƒä¿¡æ¯
        env_info = memory_system.path_memory.get("virtual_envs", {})
        if env_info:
            tool_params["env_context"] = env_info
    
    # å¦‚æœæ¶‰åŠæ–‡ä»¶åˆ›å»ºï¼Œè·å–æ™ºèƒ½è·¯å¾„å»ºè®®
    if tool_name == "create_file" and "path" in tool_params:
        smart_path = memory_system.get_smart_file_location(
            tool_params["path"],
            {"project_root": os.getcwd()}
        )
        tool_params["suggested_path"] = smart_path
    
    # å¢å¼ºåçš„å‚æ•°æ‰§è¡Œå·¥å…·
    enhanced_params = {
        **tool_params,
        "memory_context": memory_context
    }
    
    # æ‰§è¡ŒåŸæœ‰çš„å·¥å…·è°ƒç”¨é€»è¾‘...
```

### ç¬¬ä¸‰é˜¶æ®µï¼šTODO ç®¡ç†é›†æˆï¼ˆDay 4ï¼‰

#### 1. åˆ›å»º TODO ç›‘æ§å·¥å…·

```python
# tools/simple/todo_monitor.py
"""TODO ç›‘æ§å’Œç®¡ç†å·¥å…·"""

class TodoMonitorTool(BaseTool):
    """ç›‘æ§TODOçŠ¶æ€å¹¶ç»´æŠ¤ä»»åŠ¡ä¸»çº¿"""
    
    def get_name(self) -> str:
        return "todo_monitor"
    
    async def run(self, request: ToolRequest) -> ToolOutput:
        action = request.params.get("action")
        
        if action == "check_context":
            # æ£€æŸ¥å½“å‰æ˜¯ä¸»çº¿è¿˜æ˜¯åˆ†æ”¯
            current = self.memory_system.todo_manager["current_context"]
            if current == "main":
                return self._get_main_tasks()
            else:
                return self._get_branch_info(current)
                
        elif action == "suggest_return":
            # å»ºè®®æ˜¯å¦è¯¥è¿”å›ä¸»çº¿
            return self._analyze_branch_completion()
            
        elif action == "track_progress":
            # è·Ÿè¸ªä»»åŠ¡è¿›åº¦
            return self._update_task_progress(request.params)
```

### ç¬¬å››é˜¶æ®µï¼šç³»ç»Ÿæç¤ºè¯é…ç½®ï¼ˆDay 5ï¼‰

#### 1. åˆ›å»ºè®°å¿†ç³»ç»Ÿæç¤ºè¯

```markdown
# systemprompts/memory.md
You are integrated with an intelligent memory system that helps you maintain context and manage tasks effectively.

## Memory Capabilities

1. **Path Intelligence**
   - Virtual environment locations are remembered
   - Smart file creation paths based on project structure
   - Command execution contexts

2. **TODO Management**
   - Main thread tasks from TODO.md
   - Temporary branch creation for side tasks
   - Automatic return to main thread

3. **Context Preservation**
   - Session memories
   - Project-specific knowledge
   - Global preferences and patterns

## Automatic Behaviors

- When starting a session, check for virtual environment
- When creating files, use smart path suggestions
- When deviating from main tasks, consider creating a branch
- When completing side tasks, return to main thread

## Memory Usage Guidelines

1. Always check memory context before operations
2. Update memories when learning new project information
3. Use branch tasks for temporary diversions
4. Maintain focus on main TODO items
```

### ç¬¬äº”é˜¶æ®µï¼šæµ‹è¯•å’Œä¼˜åŒ–ï¼ˆDay 6ï¼‰

#### 1. åˆ›å»ºé›†æˆæµ‹è¯•

```python
# tests/test_memory_integration.py
import pytest
from tools.simple.memory import MemoryTool
from tools.workflow.thinking import ThinkingTool

@pytest.mark.asyncio
async def test_auto_venv_detection():
    """æµ‹è¯•è™šæ‹Ÿç¯å¢ƒè‡ªåŠ¨æ£€æµ‹"""
    memory_tool = MemoryTool()
    
    # åˆ›å»ºæµ‹è¯•è™šæ‹Ÿç¯å¢ƒ
    test_project = create_test_project_with_venv()
    
    # æµ‹è¯•æ£€æµ‹
    result = await memory_tool.run(ToolRequest(
        tool="memory",
        params={
            "action": "detect_venv",
            "project_path": test_project
        }
    ))
    
    assert result.status == "success"
    assert "venv_path" in json.loads(result.content)

@pytest.mark.asyncio
async def test_todo_branch_flow():
    """æµ‹è¯•TODOåˆ†æ”¯æµç¨‹"""
    memory_tool = MemoryTool()
    
    # åˆ›å»ºä¸»çº¿ä»»åŠ¡
    await memory_tool.run(ToolRequest(
        tool="memory",
        params={
            "action": "parse_todo",
            "todo_path": "test_todo.md"
        }
    ))
    
    # åˆ›å»ºåˆ†æ”¯
    branch_result = await memory_tool.run(ToolRequest(
        tool="memory",
        params={
            "action": "create_branch",
            "branch_name": "fix_urgent_bug",
            "context": "User reported critical issue"
        }
    ))
    
    # è¿”å›ä¸»çº¿
    return_result = await memory_tool.run(ToolRequest(
        tool="memory",
        params={
            "action": "return_main"
        }
    ))
    
    assert return_result.status == "success"
```

## ä½¿ç”¨ç¤ºä¾‹

### 1. è‡ªåŠ¨ç¯å¢ƒè¯†åˆ«
```python
# Claude Code å¯åŠ¨æ—¶è‡ªåŠ¨æ‰§è¡Œ
"æ£€æµ‹é¡¹ç›®è™šæ‹Ÿç¯å¢ƒ"
# ç³»ç»Ÿè‡ªåŠ¨ï¼š
# - æ‰¾åˆ° .venv/bin/python
# - è®°ä½è·¯å¾„
# - åç»­æ‰€æœ‰ pip install è‡ªåŠ¨ä½¿ç”¨æ­£ç¡®è·¯å¾„
```

### 2. æ™ºèƒ½æ–‡ä»¶åˆ›å»º
```python
# ç”¨æˆ·ï¼š"åˆ›å»ºä¸€ä¸ªæ–°çš„å·¥å…·ç±» database_helper.py"
# ç³»ç»Ÿè‡ªåŠ¨ï¼š
# - åˆ†æé¡¹ç›®ç»“æ„
# - å‘ç° utils/ ç›®å½•å­˜åœ¨
# - å»ºè®®åˆ›å»ºåœ¨ utils/database_helper.py
# - è®°ä½è¿™ä¸ªæ¨¡å¼ä¾›æœªæ¥å‚è€ƒ
```

### 3. TODO ä»»åŠ¡ç®¡ç†
```python
# ä¸»çº¿ä»»åŠ¡ï¼šå®ç°ç”¨æˆ·è®¤è¯
# ç”¨æˆ·ï¼š"ç­‰ç­‰ï¼Œæˆ‘å‘ç°äº†ä¸€ä¸ªç´§æ€¥bugéœ€è¦ä¿®å¤"
# ç³»ç»Ÿï¼š
# - åˆ›å»ºä¸´æ—¶åˆ†æ”¯ "fix_urgent_bug"
# - è®°å½•å½“å‰ä¸Šä¸‹æ–‡
# - å®Œæˆbugä¿®å¤å
# - æç¤ºï¼š"Bugå·²ä¿®å¤ï¼Œæ˜¯å¦è¿”å›ä¸»çº¿ä»»åŠ¡'å®ç°ç”¨æˆ·è®¤è¯'ï¼Ÿ"
```

## é…ç½®é€‰é¡¹

```bash
# .env æ–‡ä»¶é…ç½®
ENABLE_MEMORY_SYSTEM=true
MEMORY_AUTO_SAVE=true
MEMORY_AUTO_LOAD=true
MEMORY_STORAGE_PATH=.zen_memory
PATH_LEARNING_ENABLED=true
TODO_TRACKING_ENABLED=true
```

## å®æ–½ä¼˜åŠ¿

1. **æœ€å°ä¾µå…¥**ï¼šåŸºäºç°æœ‰æ¶æ„ï¼Œåªæ·»åŠ æ–°åŠŸèƒ½
2. **æ™ºèƒ½åŒ–é«˜**ï¼šè‡ªåŠ¨å­¦ä¹ å’Œé€‚åº”é¡¹ç›®ç»“æ„
3. **ç”¨æˆ·å‹å¥½**ï¼šå‡å°‘é‡å¤è¯¢é—®ï¼Œæé«˜æ•ˆç‡
4. **ä»»åŠ¡èšç„¦**ï¼šä¿æŒä¸»çº¿ä»»åŠ¡ä¸ä¸¢å¤±
5. **æŒç»­ä¼˜åŒ–**ï¼šä»æ¯æ¬¡äº¤äº’ä¸­å­¦ä¹ 

è¿™ä¸ªå®æ–½æ–¹æ¡ˆå……åˆ†åˆ©ç”¨äº† Zen MCP Server çš„ç°æœ‰èƒ½åŠ›ï¼Œé€šè¿‡æ™ºèƒ½è®°å¿†ç³»ç»Ÿè®© Claude Code æˆä¸ºä¸€ä¸ªçœŸæ­£"æœ‰è®°å¿†"çš„å¼€å‘åŠ©æ‰‹ã€‚